\chapter{Analysis}

%---------------------------------------------------------------
\section{Static Typing in JavaScript}
%---------------------------------------------------------------

JavaScript is a dynamically typed programming language, where users do not need to assign types to a variable or a function and the type is inferred automatically by the JavaScript engine. This is a great feature of JavaScript, which lowers the barrier of entry to writing JavaScript code and allows developers to prototype and write code quickly, proven by the growth of popularity of JavaScript in the last decade, making it the most commonly used programming language according to the 2022 Stack Overflow Developer Survey \cite{StackOverflowDeveloper}.

However, dynamic typing has its own drawbacks, as it is harder to spot trivial errors in the code without running it beforehand and it is more difficult to refactor the code without breaking it, which often lead to poor software quality \cite{fardJSNOSEDetectingJavaScript2013a}. Proponents of static typing insist that static types allows developers to spot potential bugs and mistakes earlier during development and that it allows for better tooling, such as more rich code completion and refactoring tools.

There is an upcoming TC39 proposal for adding type annotations, broadly inspired by TypeScript syntax \cite{ECMAScriptProposalType2023}. These annotation are only used for build-time tooling, these annotation are ignored in runtime and the proposal suggests these annotations to be erased by an additional build-step. Even though users can already provide static types using JSDoc right now, the syntax is not as clean as the proposed TypeScript-like syntax.

Regardless, there are many languages which aim to introduce static typing to JavaScript, such as Flow or TypeScript, or alternative languages which compile back to JavaScript, such as Elm or ReScript.

\subsection{Elm}

Elm is a functional programming language designed specifically for building web applications \cite{ElmDelightfulLanguage}. The language compiles to JavaScript and has a strong static Hindley-Milner based type system, which allows to infer types more often and reliably. Elm does not provide any escape hatches such as \code|any| in TypeScript, thus it is harder to write unsafe code, as the types must be valid in order for the code to be compiled.

Elm also includes a lot of quality-of-life improvements and benefits, for instance: enforced purity of functions, out of the box immutability, \code|case| pattern matching, JSON decoders and encoders for strict parsing, \code|Maybe| and \code|Result| monads for avoiding \code|null| and \code|undefined| references or its own virtual DOM implementation for efficient rendering of interactive user interfaces. Notably, the Elm Architecture, where the application code is organized into three parts: model, update and view \cite{ElmArchitectureIntroduction}, has greatly inspired other libraries and frameworks like Redux \cite{PriorArtRedux2022}.

\subsection{ReScript}

ReScript is a programming language built on top of OCaml toolchain. Unlike Flow or TypeScript, ReScript is not a superset of JavaScript, instead the language compiles to JavaScript. ReScript was created as a spin-off from Reason programming language and accompanying BuckleScript compiler, aiming to vertically integrate and streamline the adoption barrier caused by the need to be familiar with multiple unrelated tools and toolchains \cite{BuckleScriptReasonRebranding}.

The language aims to be more sound with more powerful type inference than TypeScript, borrowing the Hindler-Milner type system from OCaml implementation \cite{EfficientInsightfulGeneralization,HistoryReScript2022}, thus most of times the types can be inferred automatically without the need to annotate them explicitly, whereas TypeScript utilizes bidirectional type checking \cite{ReconstructingTypeScriptPart}.

\subsection{Flow}

Flow is a static type checker for JavaScript \cite{chaudhuriFastPreciseType2017,Flow2023}, which allows developers to annotate their code with static types. Flow is developed by Meta and is internally used in production by Facebook, Instagram and React Native. Type annotations in Flow are fully eraseable, which means that the type annotations can be fully removed from the Flow code to emit valid JavaScript code. The checking of these types is occurring at compile-time before removal in build-time. Flow is also a superset of JavaScript, which means any JavaScript code is a valid Flow code.

One the primary goals of Flow is to provide type soundness; the ability to catch every error that might happen in runtime at compile-time, no matter how likely it is to happen. This means, that a valid Flow code can provide developers some guarantees about the type a value has in runtime, at the expense of catching errors, which are unlikely to happen in runtime.

Both Flow and TypeScript are similar in regards to features at the time of writing. Most of the soundness differences between Flow and TypeScript has been addressed with the newer versions of TypeScript, even though soundness is a specific non-goal by the TypeScript team \cite{TypeScriptDesignGoals}. However, developers must opt-in to these features by setting \code|"strict"| to \code|"true"| in \code|tsconfig.json|, whereas in Flow these features are enabled by default.

\subsection{TypeScript}

TypeScript is a staticly typed programming language developed and maintained by Microsoft \cite{TypeScriptJavaScriptSyntax}. It is a language that compiles to JavaScript and adds static type checking to JavaScript \cite{DocumentationTypeScriptJavaScript}. Unlike Elm or ReScript, TypeScript is a syntactical subset of JavaScript, which means that any valid JavaScript code can be a valid TypeScript code\footnote{With a lax compiler configuration}. Similar to Flow, type annotation provided by the developer are fully eraseable either by the TypeScript \code|tsc| compiler or by other community build tools, such as \code|babel|\cite{BabelCompilerNext}, \code|esbuild|\cite{EsbuildExtremelyFast} or \code|swc|\cite{SWCRustbasedPlatform}.

Type system in TypeScript is considered to be less sound and more forgiving, as soundness is stated as an explicit non-goal for the design team of TypeScript \cite{TypeScriptDesignGoals}, emphasis on striking a balance between productivity and correctness. By default, TypeScript compiler is not strict and the language itself includes an escape hatch for developers to opt-out of type checking by using the \code|any| type or using \code|@ts-ignore| comment annotations. Nevertheless, with proper compiler configuration, the type system of TypeScript can be as sound as in Flow.

Both Flow and TypeScript support advanced features such as generics and utility types, with the latter supporting template string literal types and better support for conditional types, unlocking the potential of writing more expressive types, which this master thesis will further explore in more detail.

TypeScript has become the de-facto standard for writing JavaScript code with static types. With deep integration with Visual Studio Code \cite{VisualStudioCode}, rich build ecosystem and high compatibility with existing JavaScript libraries and tools, TypeScript has become one of the fastest growing language according to 2022 Octoverse report by Github \cite{Octoverse2022State}.

\section{Typescript syntax}

Types can be interpreted as sets.

A primitive value is data, that is not an object and has no methods or properties. These primitives are immutable, thus they cannot be altered. Similar to JavaScript, TypeScript has these following types for primitive values:

\begin{listing}[h]
\caption{Primitive Types}
\begin{minted}{TypeScript}
type Primitive = 
  | string | number | bigint
  | boolean | undefined | symbol | null;
\end{minted}
\end{listing}


Some primitive values represent a singular data value, such as \code{null} or \code{undefined}, but many of these primitives can represent an infinite number of values, like \code{number}, \code{bignumber} or \code{string}.

Literal types are a subset of primitive values, which are used to describe an exact possible value.

\begin{listing}[h]
\caption{Literal Types}
\begin{minted}{TypeScript}
type Literal = "foo" | 42 | true | 100n;
\end{minted}
\end{listing}

To represent data structures such as objects and arrays, we can use the following types: objects, records, tuples and arrays.

\begin{listing}[h]
\caption{Data structures}
\begin{minted}{TypeScript}
type Structures = 
  | { foo: string, bar: number }     // object
  | { [key in keyof Keys]: number }  // record
  | [number, string]                 // tuple
  | number[]                         // array
\end{minted}
\end{listing}

TypeScript uses structured typing, which means that TypeScript only validates the shape of the data. Essentially, if the data has the same shape as the type, it is considered to be of that type. This is also known as duck typing, essentially if it walks like a duck and quacks like a duck, it is a duck.

\begin{listing}[h]
\caption{Duck typing}
\begin{minted}{TypeScript}
type DuckLike = { quack: () => void; type: string };

const Duck: DuckLike = {
  quack: () => console.log("duck!"),
  type: "duck",
};

// this will be still valid
const Goose: DuckLike = {
  quack: () => console.log("goose!"),
  type: "goose",
};
\end{minted}
\end{listing}

Structured typing does include some drawbacks unlike in nominal type system, where each type is unique and sama data cannot be assigned across types, but these can be easily mitigated using literal types to acts as brands.

\begin{listing}[h]
\caption{Nominal typing in TS}
\begin{minted}{TypeScript}
type DuckLike = { quack: () => void; type: "duck" };

const Duck: DuckLike = {
  quack: () => console.log("duck!"),
  type: "duck",
};

// this will not be valid
const Goose: DuckLike = {
  quack: () => console.log("goose!"),
  type: "goose",
};
\end{minted}
\end{listing}

Types can be generalised into sets, where each type can contain a set of values. A type can be a subset or a superset of an other type.

\begin{figure}[h]
  \centering
  \resizebox{\textwidth}{!}{
    \includegraphics{text/analysis/2023-03-21-20-08-52.png}
  }
  \caption{~Types represented as sets}
\end{figure}

Similar to other sets in mathematics, types can be combined together using unions. With unions, we can broaden the scope of the type to represent multiple values.

\begin{figure}
  \centering
  \resizebox{\textwidth}{!}{
    \includegraphics{text/analysis/2023-03-21-20-00-30.png}
  }
  \caption{~Union of types}
\end{figure}

Types can also interect each other to create a more narrower type.


Set theory behind types.

\begin{itemize}
  \item Union
  \item Intersection
  \item \code{never}
  \item \code{unknown}
  \item \code{any} - it doesn't fit anywhere, essentially acting as a way to opt-out of typechecking.
\end{itemize}

Enums
\todo{Enums}

Functions and \code{void}

Void
\todo{Enums}

Arrays

\code{any}, \code{never}, \code{unknown}

Object

Generics

\begin{itemize}
  \item Terminology - generics, type arguments, return type
  \item Conditional types
  \item Recursive types
  \item Mapped types
  \item Template Literal Types
\end{itemize}

\subsection{Types and their assignability}

\begin{itemize}
  \item Primitive Types
  \item Literal Types
  \item \code{unknown}, \code{never}, \code{any}
  \item Structures (nominal vs structural typing)
  \item Unions and Intersections
\end{itemize}

\subsection{Conditional Types}
\subsection{Conditional Types}
\subsection{Recursive Types}
\subsection{Mapped Types}
\subsection{Template Literal Types}

\section{Prior Art}

\begin{itemize}
  \item \code{kawayiLinLin/typescript-lodash}
  \item \code{arielhs/ts-arithmetic}
  \item \code{ts-belt}
  \item \code{type-fest}
\end{itemize}