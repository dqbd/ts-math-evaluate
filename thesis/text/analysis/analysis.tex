\chapter{Analysis}

%---------------------------------------------------------------
\section{Static Typing in JavaScript}
%---------------------------------------------------------------

JavaScript is a dynamically typed programming language, where users do not need to assign types to a variable or a function and the type is inferred automatically by the JavaScript engine. This is a great feature of JavaScript, which lowers the barrier of entry to writing JavaScript code and allows developers to prototype and write code quickly, proven by the growth of popularity of JavaScript in the last decade, making it the most commonly used programming language according to the 2022 Stack Overflow Developer Survey \cite{StackOverflowDeveloper}.

However, dynamic typing has its drawbacks, as it is harder to spot trivial errors in the code without running it beforehand and it is more difficult to refactor the code without breaking it, which often leads to poor software quality \cite{fardJSNOSEDetectingJavaScript2013a}. Proponents of static typing insist that static types allow developers to spot potential bugs and mistakes earlier during development and that it allows for better tooling, such as more rich code completion and refactoring tools.

There is an upcoming TC39 proposal for adding type annotations, broadly inspired by TypeScript syntax \cite{ECMAScriptProposalType2023}. These annotations are only useful for build-time tooling as they are ignored in runtime. The proposal suggests that these annotations should be erased by an additional compilation step. Even though users can already provide static types using JSDoc right now, the syntax is not as clean as the proposed TypeScript-like syntax.

Regardless, many languages aim to introduce static typing to JavaScript, such as Flow or TypeScript, or alternative languages which compile back to JavaScript, such as Elm or ReScript.

\subsection{Elm}

Elm is a functional programming language designed specifically for building web applications \cite{ElmDelightfulLanguage}. The language compiles to JavaScript and has a strong static Hindley-Milner-based type system, which allows inferring types more often and reliably. Elm does not provide any escape hatches such as \code|any| in TypeScript, thus it is harder to write unsafe code, as the types must be valid for the code to be compiled.

Elm also includes a lot of quality-of-life improvements and benefits, for instance: enforced purity of functions, out-of-the-box immutability, \code|case| pattern matching, JSON decoders and encoders for strict parsing, \code|Maybe| and \code|Result| monads for avoiding \code|null| and \code|undefined| references or its own virtual DOM implementation for efficient rendering of interactive user interfaces. Notably, the Elm Architecture, where the application code is organized into three parts: model, update and view \cite{ElmArchitectureIntroduction}, has greatly inspired other libraries and frameworks like Redux \cite{PriorArtRedux2022}.

\subsection{ReScript}

ReScript is a programming language built on top of the OCaml toolchain. Unlike Flow or TypeScript, ReScript is not a superset of JavaScript, instead, the language compiles to JavaScript. ReScript was created as a spin-off from the Reason programming language and accompanying BuckleScript compiler, aiming to vertically integrate and streamline the adoption barrier caused by the need to be familiar with multiple unrelated tools and toolchains \cite{BuckleScriptReasonRebranding}.

The language aims to be more sound with more powerful type inference than TypeScript, borrowing the Hindler-Milner type system from OCaml implementation \cite{EfficientInsightfulGeneralization, HistoryReScript2022}, thus most of the time the types can be inferred automatically without the need to annotate them explicitly, whereas TypeScript utilizes bidirectional type checking \cite{ReconstructingTypeScriptPart}.

\subsection{Flow}

Flow is a static type checker for JavaScript \cite{chaudhuriFastPreciseType2017, Flow2023}, which allows developers to annotate their code with static types. Flow is developed by Meta and is internally used in production by Facebook, Instagram and React Native. Type annotations in Flow are fully erasable, which means that the type annotations can be fully removed from the Flow code to emit valid JavaScript code. The checking of these types is occurring at compile-time before removal in build-time. Flow is also a superset of JavaScript, which means any JavaScript code is a valid Flow code.

One of the primary goals of Flow is to provide type soundness; the ability to catch every error that might happen in runtime at compile-time, no matter how likely it is to happen. This means, that a valid Flow code can provide developers some guarantees about the type a value has in runtime, at the expense of catching errors, which are unlikely to happen in runtime.

Both Flow and TypeScript are similar regarding features at the time of writing. Most of the soundness differences between Flow and TypeScript have been addressed with the newer versions of TypeScript, even though soundness is a specific non-goal by the TypeScript team \cite{TypeScriptDesignGoals}. However, developers must opt-in to these features by setting \code|"strict"| to \code|"true"| in \code|tsconfig.json|, whereas in Flow these features are enabled by default.

\subsection{TypeScript}

TypeScript is a statically typed programming language developed and maintained by Microsoft \cite{TypeScriptJavaScriptSyntax}. It is a language that generates down to JavaScript and adds static type checking to JavaScript \cite{DocumentationTypeScriptJavaScript}. Unlike Elm or ReScript, TypeScript is a syntactical superset of JavaScript, which means that any valid JavaScript code can be a valid TypeScript code\footnote{With a lax type checker configuration}. Similar to Flow, type annotations provided by the developer are fully erasable either by the TypeScript \code{tsc} type checker or by other community build tools, such as \code|babel|\cite{BabelCompilerNext}, \code|esbuild|\cite{EsbuildExtremelyFast} or \code|swc|\cite{SWCRustbasedPlatform}.

Type system in TypeScript is considered to be less sound and more forgiving, as soundness is stated as an explicit non-goal for the design team of TypeScript \cite{TypeScriptDesignGoals}, with emphasis on striking a balance between productivity and correctness. By default, the TypeScript type checker is not strict and the language itself includes an escape hatch for developers to opt out of type checking by using the \code|any| type or using \code|@ts-ignore| comment annotations. Nevertheless, with proper type checker configuration, the type system of TypeScript can be as sound as in Flow.

Both Flow and TypeScript support advanced features such as generics and utility types, with the latter supporting template string literal types and better support for conditional types, unlocking the potential of writing more expressive types, which this master thesis will further explore in more detail.

TypeScript has become the de-facto standard for writing JavaScript code with static types. With deep integration with Visual Studio Code \cite{VisualStudioCode}, the rich build ecosystem and high compatibility with existing JavaScript libraries and tools, TypeScript has become one of the fastest growing languages in terms of usage according to the 2022 Octoverse report by Github \cite{Octoverse2022State}.

\section{Usage of TypeScript}

The TypeScript project is made of two major parts available to developers:

\begin{itemize}
  \item \code{tsc}: the TypeScript Compiler, which is responsible for both type checking and outputting valid JavaScript files,
  \item \code{tsserver}: the TypeScript Standalone Server, which encapsulates the TypeScript Compiler and language services for use in editors and IDEs \cite{StandaloneServerTsserver}.
\end{itemize}

Whereas a type-checker is most likely executed manually more often and is the entry point for developers when using TypeScript, the language server is equally as useful, as it communicates with the editor via Language Server Protocol (LSP) to provide important language services. These include code completion, auto-importing, symbol renaming etc.

Unlike in the other languages, the compilation step itself is understood to only mean the type erasure itself. Even though the source code itself can have various type errors, \code{tsc} will still by default emit JavaScript files, as long as the input source file can be parsed by both the scanner and the parser. This allows developers to progressively update their code and iterate quickly on the functionality without having to deal with the type errors immediately, essentially acting more as a linter than a compiler. Regardless, in this thesis, \say{compiling} and \say{type-checking} will be used interchangeably.

\section{Typescript syntax}

In TypeScript, types are annotated using \code{:[type annotation]} syntax, adding annotations to any of the symbols found in JavaScript, such as variables, function parameters and function return values, to add constraints to values. Type annotations in TypeScript can be categorized into primitive types, literal types, data structure types, union types, intersection types and type parameters. In the following sections, we will explore each of these types in more detail. The following listing \ref{lst:basic-annotation} shows a basic example of TypeScript annotations:

\begin{listing}[h]
  \caption{Basic TypeScript annotation example}\label{lst:basic-annotation}
  \begin{minted}{TypeScript}
const item: string = "Hello world"
function add(a: number, b: number): number {
  return a + b
}
\end{minted}
\end{listing}

At runtime, every variable has a single concrete value, but in TypeScript, the variable has only a type. A useful mental model for understanding types is to think of the type as a set of permitted values \cite{vanderkamEffectiveTypeScript622019}, effectively describing the domain of the type.

\subsection{Primitive Types}

A primitive value is data, that is not an object and has no methods or properties. These primitives are immutable, thus they cannot be altered. The TypeScript type system provides a comprehensive representation of these primitives, as seen in listing \ref{lst:primitive-types}:

\begin{listing}[h]
  \caption{Primitive Types}\label{lst:primitive-types}
  \begin{minted}{TypeScript}
type Primitive = 
  | string | number | bigint
  | boolean | undefined | symbol | null;
\end{minted}
\end{listing}

Some primitive values represent a singular data value, such as \code{null} or \code{undefined}, but many of these primitives can represent multiple values (\code{boolean} can represent either \code{true} or \code{false}), or even an infinite amount of values, like \code{number}, \code{bignumber} or \code{string}.

\subsection{Literal Types}

To describe an exact possible value, we can use literal types. From the point of view of the type system, a literal type is a subset of one of the following primitive types: \code{string}, \code{number}, \code{bignumber} or \code{boolean}\footnote{Both \texttt{\textcolor{blue}{null}} and \texttt{\textcolor{blue}{undefined}} are literal types as well}, as seen in Listing \ref{lst:literal-types}.

\begin{listing}[h]
  \caption{Literal Types}\label{lst:literal-types}
  \begin{minted}{TypeScript}
type Literal = "foo" | 42 | true | 100n;

// Valid code
const Valid: Literal = "foo"

// @ts-expect-error Type '"bar"' is not assignable to type 'Literal'
const Invalid: Literal = "bar" 
\end{minted}
\end{listing}

\section{Types for data structures}

TypeScript also allows annotating data structures such as objects and arrays with dedicated type syntax.

\todo{Arrays}

An array type is used to describe an array with an unknown length and the values are of the same type.

\todo{Objects, Interfaces}

Object types are used to describe an object with an enumerable and finite set of keys with values of different types per key.

\todo{keyof}

\todo{indexed access type}

\todo{Records}

Record types are used to describe an object with an unknown number of keys and the values are of the same type.

\todo{Tuples}

Similarly, tuple types describe an array with a fixed number of elements, possibly with a different type for each element.

\begin{listing}[h]
  \caption{Data structures}\label{lst:data-structures}
  \begin{minted}{TypeScript}

type ObjectStructure =  
  | { foo: string, bar: number }

type RecordStructure 
  | { [key: string]: number }
  | Record<string, number>

type TupleStructure = [number, string]

type ArrayStructure = number[]
\end{minted}
\end{listing}

\subsection{Structured Typing}

TypeScript uses structured typing, which means that TypeScript only validates the shape of the data. Essentially, if the data has the same shape as the type, it is considered to be of that type, as seen in Listing \ref{lst:structured-typing}. This is also known as duck typing, essentially: \say{If it walks like a duck and quacks like a duck, it is a duck.}

\begin{listing}[h]
  \caption{Structured typing}\label{lst:structured-typing}
  \begin{minted}{TypeScript}
type DuckLike = { quack: () => void; type: string };

const Duck: DuckLike = {
  quack: () => console.log("duck!"),
  type: "duck",
};

// this will be still valid
const Goose: DuckLike = {
  quack: () => console.log("goose!"),
  type: "goose",
};
\end{minted}
\end{listing}

Structured typing does include some drawbacks unlike in nominal type systems, where each type is unique and the same data cannot be assigned across types, but these can be easily mitigated using literal types to act as brands, as seen in Listing \ref{lst:nominal-types-emulation}.

\begin{listing}[h]
  \caption{Nominal typing in TS}\label{lst:nominal-types-emulation}
  \begin{minted}{TypeScript}
type DuckLike = { quack: () => void; type: "duck" };

const Duck: DuckLike = {
  quack: () => console.log("duck!"),
  type: "duck",
};

// this will not be valid
const Goose: DuckLike = {
  quack: () => console.log("goose!"),
  type: "goose",
};
\end{minted}
\end{listing}

\subsection{Union and intersection types}

Revisiting the notion of types as sets of values, as seen in Listing \ref{lst:literal-types}, when attempting to assign a value not permitted by the \code{Literal} type, a type error occurs. In the world of TypeScript, a type is \say{assignable}, if it is either a \say{member of} the set of permitted values defined by the type (when describing relationships between a value and a type) or it is a \say{subset of} the sets (when describing relationships between two types).

Sometimes, we need to describe a type, which is a combination of multiple types, combining two sets of values into a single set. This is achievable by using the union operator represented by the \code{|} symbol to describe a type that represents a value, which may be any of one of the combined types referred to as \say{union members} \cite{DocumentationEverydayTypes}. Essentially, \code{X | Y} can be read as a type for a value that can either be of type \code{X} or \code{Y}.

Because behind a union type may be a value of any of the union member types, TypeScript will allow only operations, which are valid for every union member. If we want to perform an operation which valid for some of the union members, we must perform type narrowing, which refines a broader type to a more specific narrow one, capturing a subset of values of the original broader type.

An example can be seen in Listing \ref{lst:union-types}, where the function \code{printUserId} can accept both a \code{string} or a \code{number} as an argument. To invoke \code{toUpperCase()}, a method valid only for values of \code{string} type, we must perform a check, if the parameter is a \code{string}. Afterward, TypeScript is smart enough to infer that the type of the checked value must be necessary a \code{string} and permits the invocation of \code{toUpperCase()}.

\begin{listing}[h]
  \caption{Union types with simple narrowing}\label{lst:union-types}
  \begin{minted}{TypeScript}
function printUserId(id: string | number) {
  if (typeof id === "string") {
    return id.toUpperCase()
  } else {
    return id
  }
}
  \end{minted}
\end{listing}

Whereas an intersection of types can be represented by the \code{&} operator. Similarly to the union type, \code{X & Y} can be read as a type for a value that can simultaneously belong to type \code{X} and \code{Y}. These intersection types are of particular interest when working with object types, as an intersection of two object types has all properties of both object types, as an object with both of the properties can be assigned to both of the intersection member types. For this particular reason, intersection types are commonly used to merge two object types, as seen in \ref{lst:intersection-types}\footnote{We can also use \texttt{\textcolor{blue}{extends}} keyword to merge two interfaces}.

\begin{listing}[h]
  \caption{Intersection types}\label{lst:intersection-types}
  \begin{minted}{TypeScript}
type Intersection = { a: string } & { b: number }
const item: Intersection = { a: "a", b: 1 }
  \end{minted}
\end{listing}

\subsection{Special data types}

When working with unions and intersections, we need to be able to describe a type, which can describe a union of all possible types or a type, which is created by intersecting two types with no related properties. We refer to these types as universal supertypes and universal subtypes respectively. Universal supertypes, also known as top types, are types that are a superset of all other types and are used to represent any possible value. Whereas universal subtypes, also known as bottom types, are types that are a subset of all other types and are often used to describe a type that has no permitted values.

TypeScript includes two top universal supertypes: \code{any} and \code{unknown}. In the case of \code{any}, every type is assignable to type \code{any} and type \code{any} is assignable to every type \cite{TopTypesAny}. \code{any} is acting as an escape hatch to opt out of type checking. This does have unintended consequences, as \code{any} is assignable to every type, it can be assigned to a different type without any warnings. This is especially problematic when dealing with external data as the return type of \code{JSON.parse()} is \code{any}. An example of assignability can be seen at Listing \ref{lst:any-assignability}.

\begin{listing}[h]
  \caption{Assignability of any}\label{lst:any-assignability}
  \begin{minted}{TypeScript}
let data: any = JSON.parse("...") 

// all of these are valid TypeScript code
data = null
data = true
data = {}

// still valid code, opting out of type checking
const a: null = data
const b: boolean = data
const c: object = data
  \end{minted}
\end{listing}

\code{unknown} acts as a more restrictive version of \code{any}. Every type is assignable to type \code{unknown}, but \code{unknown} is not assignable to any other type, which can be seen at Listing \ref{lst:unknown-assignability}. To assign \code{unknown} to a different type, we must narrow the types using either type guards, type assertions, equality checks or other assertion functions.

\begin{listing}[h]
  \caption{Assignability of unknown}\label{lst:unknown-assignability}
  \begin{minted}{TypeScript}
let data: unknown = JSON.parse("...") 

// all of these are valid TypeScript code
data = null
data = true
data = {}

// not valid, as unknown is not assignable to any other type
const a: null = data
const b: boolean = data
const c: object = data
  \end{minted}
\end{listing}

Finally, \code{never} is a bottom type, acting as a subtype of all other types, representing a value that should never occur. In the context of the theory of mathematical logic, \code{never} acts as a logical contradiction, describing a value that may never exist. No other type can be assigned to \code{never} nor \code{never} cannot be assigned to any other type. \code{never} can be found when attempting to intersect two types that have no properties in common, such as \code{string & number}.

\code{void} is a specific type used to signify a function, which does not return a value. There is a notable difference between the usage of \code{void} when used in context, describing a type for a function with \code{void} return type, and when used in the function declaration, as seen in Listing \ref{lst:void-return-type}. The former is used to describe a situation when an implementation of a \say{void function} does return a value but should be ignored. The latter does enforce that a function should not return a value at all.

\begin{listing}[h]
  \caption{Return type void}\label{lst:void-return-type}
  \begin{minted}{TypeScript}
type voidFn = () => void

// Valid code
const fn1: voidFn = () => true

function fn2(): void {
  // @ts-expect-error Not valid, as void functions cannot return a value
  return true
}
\end{minted}
\end{listing}

\subsection{Enumerations}

\code{enum} type is a distinct subtype used to describe a set of named constants. Instead of using individual variables for each constant, an \code{enum} provides an organized way to express a collection of related values. \code{enum} is one of the few TypeScript features which introduce an additional code added to the compiler output and enums refer to real objects at runtime.

An \code{enum} type consists of members and their corresponding initializers for the runtime value of the member. There are two types of enums in TypeScript: numeric enums and string-based enums. In numeric enums, each member is assigned a numeric literal value, as seen in Listing \ref{lst:numeric-enums}. Each member can have an optional initializer to specify an exact number corresponding to a member. If omitted, the value of the member will be generated by auto-incrementing from previous members.

\begin{listing}[h]
  \caption{Numeric enums}\label{lst:numeric-enums}
  \begin{minted}{TypeScript}
enum Direction {
  Up = 1,
  Down,
  Left,
  Right,
}
\end{minted}
\end{listing}

String-based enums are similar in nature, where each member is assigned a string literal value instead. Each member thus must have an initializer with a string literal, as seen in Listing \ref{lst:string-based-enums}. The key benefit of string-based enums is that they tend to keep their semantic value well when serializing, which is especially helpful when debugging, as the values of numeric enums tend to be opaque.

\begin{listing}[h]
  \caption{String-based enums}\label{lst:string-based-enums}
  \begin{minted}{TypeScript}
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}
\end{minted}
\end{listing}

\subsection{Generic Types}

Sometimes we need to write code, which needs to work and accept types we don't know in advance. Generic types allow the development of such reusable components that can work over a variety of types rather than a single one. Generic types are created by defining a type parameter that can be used as a placeholder for a specific type. The consumers will be then able to replace the placeholder with their own desired types when using the component. In TypeScript, generic types can be defined on interfaces, functions and classes.

To illustrate the point, consider the implementation of the built-in \code{Array} type found in the \code{lib.*.d.ts} files (a subset can be seen at Listing \ref{lst:array-type}). The \code{Array<T>} is a generic type, which accepts a single type argument \code{T} and is used to describe the type of the elements in the array. The type argument \code{T} is later used both in arguments and return types of the methods of the \code{Array<T>} type: \code{push()} accepts only elements of the same type as the array while \code{pop()} will return an element of the same type.

\begin{listing}[h]
  \caption{Array type}\label{lst:array-type}
  \begin{minted}{TypeScript}
interface Array<T> {
  push(...items: T[]): number;

  pop(): T | undedfined;
}

const strArr: Array<string> = []
const numArr: Array<number> = []

strArr.push("one", "two")
numArr.push(1, 2)

const a = strArr.pop()
//    ^? string

const b = numArr.pop()
//    ^? number
\end{minted}
\end{listing}

Generic types can be interpreted as functions in a meta-programming language found inside the TypeScript type system itself. The meta-programming language implements some of the key concepts found in the functional programming paradigm.

Generic types are considered first-class citizens in the language, being able to be passed as arguments into other generic types, similar to functions in a functional programming language. Generic types are also pure and cannot have any side effects during type checking. We also use recursion in the meta-programming language to break down complex problems into smaller ones and solve them independently.

There is a notable omission, however: generic types cannot receive other generic types as type arguments \cite{TypeInferenceHigherorder}. Thus, higher-order functions are not permitted \footnote{There is a way to create such type using HOTScript, more on that later}.

\subsection{Type constraints with \texttt{\textcolor{blue}{extends}}}

When writing generic types, sometimes we need to be able to describe some expectations that a type argument must satisfy. For example, we might want to accept types, which do have a certain property, such as \code{length} as seen in Listing \ref{lst:extends}. To achieve this, we use the \code{extends} keyword to describe our constraints to the type.

\begin{listing}[h]
  \caption{Type constraints with \texttt{\textcolor{blue}{extends}}}\label{lst:extends}
  \begin{minted}{TypeScript}

function getLength<T extends HasLength>(obj: T): number {
  return obj.length
}

const a = getLength("hello")
const b = getLength([1, 2, 3])
const c = getLength({ length: 10 })

// @ts-expect-error 
// Argument of type '{ foo: string; }' is not 
// assignable to parameter of type 'HasLength'.
const d = getLength({ foo: "bar" })
\end{minted}
\end{listing}

The generic function will not be able to accept any types anymore, as desired and we must only pass types, which satisfy the constraints instead.

\subsection{Conditional types}

Within the TypeScript meta-language, developers can write conditions and branching logic using conditional types. Conditional types follow a syntax similar to the conditional ternary operators with another case of overloading the \code{extends} keyword: \code{Input extends Expect ? A : B}. This can be read as \say{If type Input is assignable to type Exepct, then the type resolves to type A, otherwise to type B.} An example can be seen in Listing \ref{lst:conditional-types}, where the \code{IsString<T>} type will resolve to \code{true} if the type argument \code{T} is assignable to \code{string} and to \code{false} otherwise.

\begin{listing}[h]
  \caption{Conditional types}\label{lst:conditional-types}
  \begin{minted}{TypeScript}
type IsString<T> = T extends string ? true : false
\end{minted}
\end{listing}

We can use the \code{infer} keyword to deduce or extract a specific type within the scope of conditional types, essentially acting as a way to perform pattern matching. With \code{infer} we introduce a new generic type variable, which can be later used within the true branch of the conditional type, as seen in the implementation of the \code{ReturnType<T>} utility type in Listing \ref{lst:infer}. The \code{ReturnType<T>} type will resolve to the return type of the type argument \code{T}.

\begin{listing}[h]
  \caption{Infer in conditional types}\label{lst:infer}
  \begin{minted}{TypeScript}
type ReturnType<T> = T extends (...args: any) => infer R ? R : never;
\end{minted}
\end{listing}

Since TypeScript version 4.7 \cite{rosenwasserAnnouncingTypeScript2022}, we can also add an additional type constraint for the inferred type, which will be checked before the conditional type is resolved. This is useful when we want to avoid an additional nested conditional type, as seen in Listing \ref{lst:infer-constraint}, where we want to return the first element of the tuple type only if it is a string.

\begin{listing}[h]
  \caption{Type constraints within infer}\label{lst:infer-constraint}
  \begin{minted}{TypeScript}
type FirstIfString<T> =
  T extends [infer S extends string, ...unknown[]]
    ? S
    : never;

// is equivalent to 
type FirstIfString<T> =
  T extends [infer S, ...unknown[]]
    ? S extends string ? S : never
    : never;
\end{minted}
\end{listing}

When given a union type within the conditional type, the conditional type will be resolved for each member type in the union separately, essentially distributing the union type. To prevent such behavior, we can wrap the type argument in a tuple or any other structure type.

\begin{listing}[h]
  \caption{Distributing union types}\label{lst:distribute}
  \begin{minted}{TypeScript}
type ToArray<Type> = Type extends any ? Type[] : never;

// $ExpectType string[] | number[]
type A = ToArray<string | number> 

type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;

// $ExpectType (string | number)[]
type B = ToArrayNonDist<string | number> 

\end{minted}
\end{listing}

\subsection{Mapped types}

Sometimes we need to transform a type into another type. For example, we might want to create a new type, which is a copy of the original type, but with all properties being optional. This can be achieved using mapped types. Mapped types are types, which are created using the syntax for index signatures, commonly used in JavaScript for properties not declared ahead of time. An example is shown in Listing \ref{lst:mapped-types}, where the generic type \code{ToBoolean<T>} will create a new type which will take all properties from \code{T} and change their values to \code{boolean}.

We can also specify mapping modifiers to affect the mutability or optionality of a property: \code{readonly} and \code{?} respectively. Prefixing the modifier with either \code{+} or \code{-} will either add or remove the modifier to the property\footnote{+ is assumed by default if omitted}. This can be seen in the \code{Optional<T>} type in Listing \ref{lst:mapped-types}, which will create a new type, which is a copy of the original type, but with all properties being optional.

\begin{listing}[h]
  \caption{Mapped types}\label{lst:mapped-types}
  \begin{minted}{TypeScript}
type ToBoolean<T> = {
  [K in keyof T]: boolean
}

type Optional<T> = {
  [K in keyof T]+?: T[K]
}
\end{minted}
\end{listing}

Introduced in TypeScript 4.1 \cite{rosenwasserAnnouncingTypeScript2020}, we can also use the \code{as} keyword to re-map keys in mapped types. This can allow us to create, transform or filter out keys when creating a new type. An example is shown in Listing \ref{lst:mapped-as}, where the \code{Omit<T, Key>} creates a new object type based on type \code{T} with omitted properties which are assignable to \code{Key}.

\begin{listing}[h]
  \caption{Using as in mapped types}\label{lst:mapped-as}
  \begin{minted}{TypeScript}
type Omit<T, Key> = {
  [K in keyof T as Exclude<K, Key>]: T[K]
}
\end{minted}
\end{listing}

\subsection{Recursive Types}

\subsection{Template Literal Types}

\section{Prior Art}

\begin{itemize}
  \item \code{kawayiLinLin/typescript-lodash}
  \item \code{arielhs/ts-arithmetic}
  \item \code{ts-belt}
  \item \code{type-fest}
  \item \code{hotscript}
\end{itemize}