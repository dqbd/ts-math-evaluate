\section{Statement parser and evaluator}

The generic types for mathematical operations are well suited for simple expressions. However, the proposed interface can be too verbose when describing complex formulas. A more elegant solution is to represent both input and output as a literal string type and let a compiler do the parsing and evaluation of the expression. The input literal string type will contain a mathematical expression in infix notation, and the output literal string type will contain the result of the expression. The compiler is built in three parts: the lexer, the parser and the evaluator, which will be described in the following sections.

\subsection{Lexer}

The lexical analyser (lexer) is responsible for dividing the input literal string type into a sequence of meaningful units called tokens. The goal of a lexer is to remove whitespaces and inconsistencies to simplify the input stream, which is helpful for later stages of parsing. One such example is the parsing of numbers: consuming a single number token is easier than parsing each digit of a number, which can unnecessarily complicate the design of a parser.

The following section will provide an in-depth look into the handwritten lexer implementation. Namespaces have been used to describe the object types representing tokens, ensuring proper isolation between different type aliases and preventing naming clashes without the need to resort to prefixing. An example can be seen in \ref{lst:lexer-token-namespace}, where \code{Plus} and \code{Minus} are type aliases for the object types, whereas \vcode{_} is a union type for when a placeholder for a token is needed. Also, instead of utilising the \code{never} type for errors, a string enum is used to prevent unintended matches when performing assignability checks, as \code{never} is a subtype of all types.

\begin{listing}[ht]
  \caption{Lexer token namespace}\label{lst:lexer-token-namespace}
  \begin{minted}{TypeScript}
enum Error {
  Lexer = "LexerError",
  Parser = "ParserError",
}

namespace Token {
  export type Plus = { type: "Plus" } 
  export type Minus = { type: "Minus" } 
  export type _ = Plus | Minus
} 
\end{minted}
\end{listing}

The lexing itself is done by a generic type, which accepts a literal string type as a type argument and returns either a string enum as an error or an object type containing the matched token and the remaining unparsed input. As seen in Listing \code{lst:lexer-structure}, the \code{HandleToken} attempts to perform pattern matching on the first character of the input string literal type \code{T}. If succeeded, the matched token is returned wrapped in an object type defined by \code{LexResult} generic type, passing both the matched token and the remaining input to the next iteration of the \code{HandleToken} generic type. If the pattern matching fails, the \code{Error.Lexer} string enum is returned instead. This structure can be chained together to create a lexer for multiple token types, such as function keywords or numbers.

\begin{listing}[ht]
  \caption{Lexer Structure}\label{lst:lexer-structure}
  \begin{minted}{TypeScript}
type LexResult<Rest extends string, Result extends Token._> = {
  result: Result
  rest: Rest
}
type HandleToken<T extends string> = 
  T extends `${infer Head}${infer Rest}`
  ? Head extends "+"
    ? LexResult<Rest, Token.Plus>
    : Error.Lexer
  : Head extends "-"
    ? LexResult<Rest, Token.Minus>
    : Error.Lexer
  : Error.Lexer
\end{minted}
\end{listing}

\subsection{Parser}

Infix notation is the most common way of writing mathematical expressions and is more intuitive for humans to read and write. However, it is not ideal for computers due to the complexity of parsing algorithms, which must adequately evaluate parentheses and operator precedence rules. Postfix notation addresses the shortcomings of infix notation by explicitly stating the order of computation, making the evaluation unambiguous.

Various methods exist for converting an expression in infix notation. However, this thesis focuses on implementing a top-down LL(1) parser for mathematical expression. The main reason for choosing the LL(1) parser is the extendibility and suitability for supporting other LL(1) grammars more readily. Some other common parsers were considered for this thesis, including the Shunting-Yard algorithm, using two stacks for operators and output operands, and the Pratt parser, a recursive descent parsing algorithm utilising a precedence table for extendability.


Grammar is a set of rules that defines the syntax of a language. The grammar consists of a set of terminals, non-terminals, a set of production rules and a start symbol. Terminals are the basic unit of the language, while non-terminals are placeholders for other terminals and non-terminals. Production rules define how non-terminals can be expanded into a sequence of other non-terminals and terminals while the start symbol defines the starting non-terminal.

Derivation

Leftmost derivation

Rightmost derivation

Ambiguous grammar

Table of operator precedence


\begin{table}[h]
  \centering
  \begin{tabular}{|c|l|l|}
    \hline
    \textbf{Precedence} & \textbf{Operator Type}              & \textbf{Associativity} \\ \hline
    1                   & Addition, Subtraction               & left-to-right          \\ \hline
    2                   & Multiplication, Division, Remainder & left-to-right          \\ \hline
    3                   & Factorial                           & non-associative        \\ \hline
    4                   & Unary plus, Unary negation          & non-associative        \\ \hline
    5                   & Exponentiation                      & right-to-left          \\ \hline
    6                   & Function call                       & non-associative        \\ \hline
    7                   & Grouping                            & non-associative        \\ \hline
  \end{tabular}
  \caption{Associativity and precedence rules for math expression}
  \label{table:associativity}
\end{table}


LL(1) parsers are a class of top-down parsers that read inputs from left to right and construct a leftmost derivation of the input. They use a single token of lookahead when parsing a sentence, meaning that the parser can only see the next token before parsing. LL(1) parsers recognise LL(1) grammars, which are a special case of context-free grammars. The grammar must be unambiguous, left-recursive and with no common prefixes among the alternatives of any expansion rule. The grammar used for this thesis is as follows (Figure \ref{fig:math-grammar}):

\begin{figure}[ht]
  \begin{multicols}{2}
    \begin{enumerate}
      \item \code{START} $\rightarrow$ \code{ADD} .

      \item \code{ADD} $\rightarrow$ \code{MUL} \code{ADDx} .
      \item \code{ADDx} $\rightarrow$ \mcode{"+"} \code{MUL} \code{ADDx} .
      \item \code{ADDx} $\rightarrow$ \mcode{"-"} \code{MUL} \code{ADDx} .
      \item \code{ADDx} $\rightarrow$ \code{$\varepsilon$} .

      \item \code{MUL} $\rightarrow$ \code{FACT} \code{MULx} .
      \item \code{MULx} $\rightarrow$ \mcode{"*"} \code{FACT} \code{MULx} .
      \item \code{MULx} $\rightarrow$ \mcode{"/"} \code{FACT} \code{MULx} .
      \item \code{MULx} $\rightarrow$ \mcode{"%"} \code{FACT} \code{MULx} .

      \item \code{FACT} $\rightarrow$ \code{UNARY} \code{FACTx} .
      \item \code{FACTx} $\rightarrow$ \mcode{"!"} \code{FACTx} .
      \item \code{FACTx} $\rightarrow$ \code{$\varepsilon$} .

      \item \code{UNARY} $\rightarrow$ \mcode{"-"} \code{UNARY} .
      \item \code{UNARY} $\rightarrow$ \mcode{"+"} \code{UNARY} .
      \item \code{UNARY} $\rightarrow$ \code{POW} .

      \item \code{POW} $\rightarrow$ \code{TERM} \code{POWx} .
      \item \code{POWx} $\rightarrow$ \mcode{"^"} \code{POW} .
      \item \code{POWx} $\rightarrow$ \code{$\varepsilon$}.

      \item \code{TERM} $\rightarrow$ \mcode{"unary"} \mcode{"("} \code{ADD} \mcode{")"} .
      \item \code{TERM} $\rightarrow$ \mcode{"binary"} \mcode{"("} \code{ADD} \mcode{","} \code{ADD} \mcode{")"} .
      \item \code{TERM} $\rightarrow$ \mcode{"("} \code{ADD} \mcode{")"} .
      \item \code{TERM} $\rightarrow$ \mcode{"number"} .
    \end{enumerate}
  \end{multicols}
  \caption{LL(1) grammar for mathematical expressions}
  \label{fig:math-grammar}
\end{figure}



Grammar
- Production
- Non-terminal
- Terminal


Operator precedence is baked into the grammar by having the higher precedence operators at the later parts of the grammar. The left-associativity and right-associativity is defined by the way how the recursion has been defined in the grammar. As seen Table \ref{table:associativity-grammar}, the position of the non-terminal is the deciding factor for associativity.

\todo{Description of the math grammar, how we ensure operator precedence and left/right-associativity}

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    Left associativity & Right associativity                                                \\
    \hline

    \makecell{
    \code{ADD} $\rightarrow$ \code{TERM} \code{.}                                           \\
      \code{ADD} $\rightarrow$ \code{ADD} \mintinline{TypeScript}{"+"} \code{TERM} \code{.}
    }
                       &
    \makecell{
    \code{ADD} $\rightarrow$ \code{TERM} \code{.}                                           \\
      \code{ADD} $\rightarrow$ \code{TERM} \mintinline{TypeScript}{"+"} \code{ADD} \code{.}
    }

    \\
    \hline

    \makecell{
    \code{ADD} $\rightarrow$ \code{TERM} \code{ADD'} \code{.}                               \\
    \code{ADD'} $\rightarrow$ \mintinline{TypeScript}{"+"} \code{TERM} \code{ADD'} \code{.} \\
      \code{ADD'} $\rightarrow$ \code{.}
    }
                       &

    \makecell{
    \code{ADD} $\rightarrow$ \code{TERM} \code{ADD'} \code{.}                               \\
    \code{ADD'} $\rightarrow$ \mintinline{TypeScript}{"+"} \code{ADD} \code{.}              \\
      \code{ADD'} $\rightarrow$ \code{.}
    }
    \\
    \hline
  \end{tabular}
  \caption{Grammar comparison between left-associativity and right-associativity}
  \label{table:associativity-grammar}
\end{table}

A custom code generation tool has been developed to generate an appropriate parser from the LL(1) grammar. Assuming the grammar is a LL(1) grammar, both the FIRST and FOLLOW set is generated for each of the non-terminals in the grammar. The parsing table is created using the FIRST and FOLLOW sets.

The FIRST set of a non-terminal is a set of terminals, that can appear as the first symbol in a string derived from that non-terminal. The FOLLOW set of a non-terminal is a set of terminals that can appear immediately after the non-terminal.

The parsing table is created as follows: for each of the production rule $A \rightarrow \alpha$ found in the grammar, do the following:

\begin{enumerate}
  \item For each terminal $a$ in the FIRST(A), add $A \rightarrow \alpha$ to the parsing table at the position $[A, a]$.
  \item If the EOF token is in the FIRST(A) set, add $A \rightarrow \alpha$ to the parsing at position $[A, b]$ for each terminal $b$ in the FOLLOW(A) set.
\end{enumerate}

\subsection{Evaluator}

The evaluator traverses the AST and evaluates each node of the AST, returning the result of the expression as a literal string type.

The evaluator itself is not required per se, and the expression can be evaluated directly in the parser, but to avoid the instantiation depth limit and to simplify debugging and unit testing, the parser emits an AST as a temporary result, and the evaluation is performed in a separate step.
