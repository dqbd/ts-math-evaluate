\section{Division}

The implementation of the division algorithm is split into two main parts: the Euclidean division and the long division algorithm. Given two integers, a dividend $x$ and a divisor $y$, the Euclidean division aims to find a quotient $q$ and a remainder $r$, which satisfies the following equation:

$$x = y\cdot q + r \qquad \text{if } 0 \le r < |b|$$

The Euclidean algorithm finds the quotient and the remainder using repeated subtraction as seen in \ref{lst:euclidean-division}. The \code{DivisionResult} contains both the temporary quotient and remainder values passed to the next iteration. The \code{EuclideanDivision} generic type first checks if the remainder is greater than or equal to the divisor. If that is the case, the quotient is incremented by one using \code{AddInt} generic type and the remainder is subtracted by the divisor using \code{SubDigit}. The process is repeated until the remainder is less than the divisor, at which point the computed quotient and remainder are returned.

\begin{listing}[ht]
\caption{Euclidean division}\label{lst:euclidean-division}
\begin{minted}{TypeScript}
interface DivisionResult<
  Quotient extends Digit[] = Digit[],
  Remainder extends Digit[] = Digit[]
> { quotient: Quotient; remainder: Remainder }

type EuclideanDivision<
  Dividend extends Digit[],
  Divisor extends Digit[],
  Tmp extends DivisionResult = DivisionResult<[0], Dividend>
> = CompareDigits<Tmp["remainder"], Divisor> extends 1 | 0
  ? EuclideanDivision<
      Dividend,
      Divisor,
      DivisionResult<
        AddInt<Tmp["quotient"], [1]>,
        SubDigit<Tmp["remainder"], Divisor>
      >
    >
  : DivisionResult<TrimStart<Tmp["quotient"]>, TrimStart<Tmp["remainder"]>>
\end{minted}
\end{listing}

The long division algorithm builds on top of the Euclidean division. An implementation can be seen in \ref{lst:long-division}.

\todo{Rewrite this section}

\begin{itemize}
  \item First, initialise the \code{Tmp} type argument to contain the division quotient and remainder set to 0.
  \item Concatenate a digit from the left to the remainder from \code{Tmp}, which is then passed to the Euclidean division algorithm.
  \item The next \code{LongDivisionDigit} invocation takes the remaining dividend and the divisor, and a new \code{DividionResult} object type instance, with remained copied and quotient concatenated from the Euclidean division.
  \item The process is repeated until no digits remain in the dividend, at which point the quotient and remainder are returned, with the leading zeros trimmed.
\end{itemize}


\begin{listing}[ht]
\caption{Long division}\label{lst:long-division}
\begin{minted}{TypeScript}
type LongDivisionDigit<
  Dividend extends Digit[],
  Divisor extends Digit[],
  Tmp extends DivisionResult = DivisionResult<[], []>
> = Dividend extends [
  infer Head extends Digit,
  ...infer RestDividend extends Digit[]
]
  ? EuclideanDivision<
      [...Tmp["remainder"], Head],
      Divisor
    > extends infer IntDivision extends DivisionResult
    ? LongDivisionDigit<
        RestDividend,
        Divisor,
        DivisionResult<
          [...Tmp["quotient"], ...IntDivision["quotient"]],
          IntDivision["remainder"]
        >
      >
    : never
  : DivisionResult<TrimStart<Tmp["quotient"]>, TrimStart<Tmp["remainder"]>>
\end{minted}
\end{listing}

To bypass the instantiation depth limit imposed by TypeScript, a new instance type can be used by using conditional types with inference to create a new type instance. 
