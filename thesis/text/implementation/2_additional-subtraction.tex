\section{Addition and Subtraction}

When representing the numbers as tuple lengths, some operations, such as addition and subtraction, can be easily implemented by spreading or inference, as seen in Listing \ref{lst:tuple-addition}. In the case of the addition operation, a new tuple type is created by spreading the elements of both tuples into a new tuple, which is then used to obtain the length representing the result.

\begin{listing}[ht]
  \begin{minted}{TypeScript}
type Add<A extends number, B extends number> = [
  ...ParseNumber<A>, 
  ...ParseNumber<B>
]['length']
\end{minted}
  \caption{Addition with tuple types}\label{lst:tuple-addition}
\end{listing}

The subtraction operation, assuming the first number is larger than the second one, is implemented with the idea that the tuple type of a first number contains all of the elements of the second number with a remainder. As seen in Listing \ref{lst:tuple-subtraction}, the \code{Subtract} generic type accepts two type arguments, \code{A} and \code{B}, which represent the numbers to subtract. A conditional type is used to check if \code{ParseNumber<A>} is assignable to a tuple that contains the elements of \code{ParseNumber<B>} followed by a remainder of the \code{number[]} type, inferred in a new type named \code{Remainder}. If true, the length of the \code{Remainder} is returned as the result of the subtraction operation. Otherwise, the \code{never} type is returned instead.

\begin{listing}[ht]
  \begin{minted}{TypeScript}
type Subtract<
  A extends string | number,
  B extends string | number
> = ParseNumber<A> extends [
  ...infer Remainder extends number[],
  ...ParseNumber<B>
]
  ? Remainder["length"]
  : never
\end{minted}
  \caption{Subtraction with tuple types}\label{lst:tuple-subtraction}
\end{listing}

As described in the previous section, the final implementation of the addition operation based on object representation of numbers is the traditional schoolbook addition with carry. The algorithm adds the numbers digit by digit and keeps track of the carry as it moves from one digit to the next. This technique has a time complexity of $\Theta(n)$, where $n$ is the number of digits in the number being added.

The core building block of the schoolbook addition and subtraction algorithm is the ability to obtain the next digit alongside the carry or borrow flag when performing the operation on single decimal digits. This can be purely done in the type system alone using tuple expansion and checking for the stringified length of the tuple, as seen in \ref{lst:generated-operations}, but to improve the performance and avoid unnecessary type instantiations, a lookup table is used to obtain the next digit and the carry flag instead. The subtraction operation is implemented similarly, where a two-dimensional lookup table of tuples is used to obtain the next digit and the borrow flag.

The lookup table is created by iterating over all possible combinations of two digits and storing the result of the addition and the carry flag in a two-dimensional map. To improve the performance even further, the lookup tables of both the addition and subtraction operations are generated as a built step in JavaScript and stored in a separate file, which is later imported into the type system.

\begin{listing}[ht]
  \begin{minted}{TypeScript}
type AddDigitsResult<A extends Digit, B extends Digit> =
    [...ParseNumber<A>, ...ParseNumber<B>]["length"] extends 
    infer Length extends number
    ? `${Length}` extends `${Digit}${infer Value extends Digit}`
      ? [Value, true]
      : `${Length}` extends `${infer Value extends Digit}`
        ? [Value, false]
        : never
    : never

// This is generated by a build step
type AddMapCarry = {
  [A in Digit]: {
    [B in Digit]: AddDigitsResult<A, B>
  }
}
\end{minted}
  \caption{Lookup table for addition operation}\label{lst:generated-operations}
\end{listing}

The schoolbook addition algorithm, seen in Listing \ref{lst:addition-algorithm}, is implemented as three generic types. \code{AddWithCarry} accepts two digits named \code{Left} and \code{Right} and a carry flag as type arguments and is responsible for adding the two digits and propagating the carry flag to the next digit. It will first check if the \code{Carry} type is assignable to \code{true}, and if it is assignable, it will increment the \code{Left} digit. The \code{AddMapCarry} is used to obtain the result, and the \code{Or} generic type implements the binary disjunction operation to determine the carry flag in case of multiple additions due to \code{Carry} being true.

\code{AddArr} is responsible for adding two tuples of digits. \code{AddArr} will attempt to extract the rightmost digit from both tuples and add them using \code{AddWithCarry}. The \code{AddArr} will be called recursively with the remaining digits and the carry flag from the previous addition until both of the tuples are empty. Note that both of the digit tuples must have the same length to prevent premature bailouts.

Finally, \code{AddInt} will add two digit tuples by first padding them into tuples of the same length by prefixing them with zeroes and then calling \code{AddArr} to perform addition itself. If \code{Carry} is assignable to \code{true}, an extra \code{1} digit is prepended to the result.

These foundational blocks can be further chained to add support for fractional numbers and signed numbers. As seen in Listing \ref{lst:addition-algorithm}, \code{AddFloatNumber} will first extract the integer and fractional parts of a number, performing integer addition on both parts separately. The carry flag is propagated appropriately from the fractional part to the integer part by recursively calling \code{AddFloatNumber} to increment the result.

\begin{listing}[ht!]
  \begin{minted}{TypeScript}
type AddFloatNumber<
A extends FloatNumber,
B extends FloatNumber
> = PadFloat<A, B> extends [
  FloatNumber<infer IntA, infer FracA>,
  FloatNumber<infer IntB, infer FracB>
]
? AddArr<FracA, FracB> extends [
    infer FracResult extends Digit[],
    infer FracCarry extends boolean
  ]
  ? AddArr<IntA, IntB> extends [
      infer IntResult extends Digit[],
      infer IntCarry extends boolean
    ]
    ? IntCarry extends true
      ? FracCarry extends true
        ? AddFloatNumber<
            FloatNumber<[1, ...IntResult], FracResult>,
            FloatNumber<[1], []>
          >
        : FloatNumber<[1, ...IntResult], FracResult>
      : FracCarry extends true
      ? AddFloatNumber<
          FloatNumber<IntResult, FracResult>,
          FloatNumber<[1], []>
        >
      : FloatNumber<IntResult, FracResult>
    : never
  : never
: never
\end{minted}
  \caption{Floating point addition}\label{lst:addition-float}
\end{listing}

When working with subtraction, underflows are resolved by implementing digit comparison. Similarly to addition and subtraction, the comparison operation is performed per digit, utilising an additional two-dimensional lookup table with all possible digit comparison results represented as a number from the following set: $\{ -1, 0, 1 \}$. Based on the comparison result, the operation can be decided by using a map object type with the comparison result as the key and the operation as the value, seen in Listing \ref{lst:subtractor-switching}.

\begin{listing}[ht!]
  \begin{minted}{TypeScript}
type SubOperatorSwitch<A extends FloatNumber, B extends FloatNumber> = {
  [-1]: SignFloatNumber<"-", SubFloatNumber<B, A>>
  [0]: SignFloatNumber<"+", FloatNumber<[0], []>>
  [1]: SignFloatNumber<"+", SubFloatNumber<A, B>>
}[CompareAbsNumbers<A, B>]
\end{minted}
  \caption{Subtraction switching}\label{lst:subtractor-switching}
\end{listing}

Finally, to simplify dealing with signed operations, an object type with all possible sign pairs can be used to determine whether to invoke addition or subtraction, as seen in Listing \ref{lst:addition-signed}.

\begin{listing}[ht]
  \begin{minted}{TypeScript}
type AddSignFloatNumber<
  A extends SignFloatNumber,
  B extends SignFloatNumber
> = {
  "+": {
    "+": SignFloatNumber<"+", AddFloatNumber<A["float"], B["float"]>>
    "-": SubOperatorSwitch<A["float"], B["float"]>
  }
  "-": {
    "+": SubOperatorSwitch<B["float"], A["float"]>
    "-": SignFloatNumber<"-", AddFloatNumber<A["float"], B["float"]>>
  }
}[A["sign"]][B["sign"]]
\end{minted}
  \caption{Signed number addition and subtraction}\label{lst:addition-signed}
\end{listing}

\begin{listing}[ht!]
  \begin{minted}{TypeScript}
type AddWithCarry<
  Left extends number,
  Right extends number,
  Carry extends boolean
  > = Carry extends true
  ? AddMapCarry[Left][1] extends [
      infer LeftTmp extends number,
      infer LeftCarry extends boolean
    ]
    ? AddWithCarry<LeftTmp, Right, false> extends [
        infer Result extends number,
        infer RightCarry extends boolean
      ]
      ? [Result, Or<LeftCarry, RightCarry>]
      : never
    : never
  : AddMapCarry[Left][Right]

type AddArr<
  A extends number[],
  B extends number[],
  Tmp extends [number[], boolean] = [[], false]
> = [A, B, Tmp] extends [
  [...infer ARest extends number[], infer ARight extends number],
  [...infer BRest extends number[], infer BRight extends number],
  [infer Result extends number[], infer Carry extends boolean]
]
  ? AddWithCarry<ARight, BRight, Carry> extends [
      infer Digit extends number,
      infer Carry extends boolean
    ]
    ? AddArr<ARest, BRest, [[Digit, ...Result], Carry]>
    : never
  : Tmp

export type AddInt<A extends Digit[], B extends Digit[]> = PadStartEqually<
  A,
  B
> extends [infer PA extends Digit[], infer PB extends Digit[]]
  ? AddArr<PA, PB> extends [
      infer Rest extends Digit[],
      infer Carry extends boolean
    ]
    ? Carry extends true
      ? [1, ...Rest]
      : Rest
    : never
  : never
\end{minted}
  \caption{Addition algorithm}\label{lst:addition-algorithm}
\end{listing}
